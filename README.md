# Overview 

`case_maker` is a tool for generating, updating, and querying a database of cases. 

Cases are entered, for ease, in a basic `.xlsx` file. This is a poor solution, but it works well for now, and has the added benefit of being easily edited by multiple people (e.g., using google docs or similar tools.)

The cases are stored in a database in the `.db` format. SQL can be used to consult the database. 

That database can then be searched, and the output it produced as a `.tex` file. 

Shell scripts manage the whole process. 

## Basic Functionality

# Classes 

The following are the list of the main classes within the code. 

# `Case`

The `Case` class is the basic building-block of the whole program, making up the single unit of an individual case entry. It contains the following: 
1. `name`, which is a `str`, and must be unique.
   * This is how any case is identified, e.g. "Robinson v Bland", "Re Melbourne"... 
2. `year`, which is an `int`.
    * E.g. 1799, 1850... 
3. `court`, which is a `str`. 
    * "KB", "Admiralty," "CP" etc. 
4. `nom_cite` which is a `str` or `None`. 
    * These are used for nominate citations, e.g. "2 Bing 314". 
5. `er_cite` which is a `str` or `None`. 
    * These are used for _English Reports_ citations (e.g. "3 ER 316") _or_; 
    * Ordinary citations, being the type that take square brackets (e.g. "AC 415"). 
    * If a case has an AC, KB, etc. citation --- it should be entered as an `er_cite`. 
6. `comment` which is a `str` or `None`. 
    * A basic string, giving relevant details or outlines of the case. 
7. `link` which is a `str` or `None`. 
   * Typically, this will be a link to `heinonline`, but other platforms and links are available. 
8. `area_tags` which is a `list` of `str` or `None`.
   * These provide the general legal or institutional context (e.g. sale, bill of exchange).
9. `subject_tags` which is a `list` of `str` or `None`.
   * These provide the relevant subject data, what _legal issues_ are involved. 
10. `cite_in_tags` which is a `dict` of `{str: str,...}` or `None`.
   * These authors are usually listed in a form that includes the works involved , e.g. "Story_Ed1" for the First Edition of Story's _Conflict of Laws_. 
   * The entries are stored as a dictionary, {author: what it is cited for}.  
11. `authors` which is a `list` of `str` or `None`.
   * These are the _authors cited by the case_. 
   * These might be cited by counsel or by the bench,or sometimes by the reporter. 
12. `special_terms` which is a`list` of `str` or `None`.
    * Special legal terms, like "_lex loci contractus_" or _privity of contract_ that are used. 

The class also contains the possibility of a `related_cases` entry. This is not used currently. 

There is also an `id` entry. **This is not entered or generated by the user, but _later_ generated within the `Casebook` object when the case is added to the relevant database.** 

### Properties 

#### `display_name` 

This is simply a `str`, comprising the name, nom_cite and er_cite, e.g: 

> Power v Whitmore (1815) 4 M&S 141, 105 ER 787

#### other `display` properties. 

This includes: 

1. `display_area_tags`
2. `display_subject_tags`
3. `display_author`
4. `display_special_terms`
5. `display_cite_ins`

All these things do is produce neat `str` versions of the various attributes of the class. 

#### `as_dict`

For the purposes of calling `Table.insert_query()`, the relevant data must be given as a `dict` of the required fields. 

`as_dict` gives a `Case` object's main information in a dictionary form: 

> {"name": f"\"{self.name}\"",
"year": f"{str(self.year)}",
"nom_cite": f"\"{self.nom_cite}\"",
"er_cite": f"\"{self.er_cite}\"",
"court": f"\"{self.court}\"",
"link": f"\"{self.link}\"",
"comment": f"\"{self.comment}\""}

This is currently used when calling `Casebook.enter_cases()`, to create a new entry in the `cases` table in the SQL. 

### Static Methods 

#### `from_excel()` 

This function takes a given row from a .xlsx file -- which is in a `tuple` form. It returns a `Case` object with the relevant data.  

## `Casebook`

The `Casebook` object is used for various purposes, and can be thought of as the "centre" of the code. It has the attributes: 

1. `cases`, which is a list of `Case` objects. 
2. `sql_connection` which is an `sqlite3.Connection` object, which links to the relevant cases. 

The design principle is that there will always be a group of cases, corresponding to those cases found in the sql database. 

### Static Methods 

#### `make_new_database` 

All this function does it take a given `sql_path` as `str`, checks if there is already a file there and, if not, create one with the required tables. 

These tables and their fields are drawn from the `DatabaseStructure()` object. 

#### `enter_cases`

This is a **beast** of a function. It takes a list of `Case` objects, and goes through a large number of processes to enter them into the required cases. 

The very tricky part of this are two functions: 

1. `enter_crossref_fields`
2. `enter_crossref_fields_with_comments`

Each of these functions takes the relevant parts of the `Case()` object and tables in the form: 

> case_object: Case, case_object_item: Case.something (e.g. "authors"), info_table: Table, info_crossref_table: Table. 

And then, using the information about the tables provided in the `DatabaseStructure.Table` objects (e.g.) `"subjects_table"`, creates the required entries. 

#### `new_casebook_from_xl`

This has the very simple use of making a brand new `Casebook` object from a `.xlsx` file and a `sql_path`. 

To do this, it calls the `make_new_database()` and `enter_cases()` methods. 

It also reads the relevant `.xlsx` file, breaking when it hits a "DONE" value. 

### Class Methods 

### Collection of `Case` objects mirrors `connection`

A **critically** important feature of the mirroring of the `Case` objects it contains and the data in the `connection` object. 

This means there _can never be_ divergence between the two. 

As such, it has been designed to mean that **you cannot update one without updating the other.** 

This will, in future, be periodically tested with the `assertCountEqual()` function. 

## `Table`

The `Table` object is found in the `sql_structure` script. 

The table object consists of two things: 

1. A `title` attribute, which is a string;
2. A `fields` attribute, which is a dict. 

The `fields` attribute includes both the name of the field and its requirements, written in SQL, e.g: 

> fields={ "id": "INTEGER PRIMARY KEY AUTOINCREMENT",
                "name": "TEXT NOT NULL UNIQUE",
                "year": "INTEGER",
                "nom_cite": "TEXT",
                "er_cite": "TEXT",
                "court": "TEXT",
                "link": "TEXT",
                "comment": "TEXT"}

### `creation_query()` 

This property returns a string based on the nature of the `Table` object itself. 

That string is an SQL query that generates the new table. 

### `insert_query()` 

This property returns an SQL query (as a string) based on the information given to it in the form of a `dict.`

It parses the `dict` in such a way that, if irrelevant information is entered, it will simply be ignored. 

If insufficent data is entered (not matching the fields in the `self.fields` dict) it will return an error. 

## `DatabaseStructure` 

This is the object which is a collection of `Table` objects. 

This has been done in this way so that the various "crossref" tables correctly reference the fields in the tables they correspond to. 

E.g: 

> subject_table=Table(
                title="subjects", fields={
                    "id": "INTEGER PRIMARY KEY AUTOINCREMENT",
                    "name": "TEXT"}
            ),

And: 

> self.subject_crossref_table = Table(
            title="subjects_crossref", fields={
                "subject_id": f"INTEGER REFERENCES {self.subject_table.title}({next(iter(self.subject_table.fields))})",
                "case_id": f"INTEGER REFERENCES {self.cases_table.title}({next(iter(self.cases_table.fields))})"}
        )



